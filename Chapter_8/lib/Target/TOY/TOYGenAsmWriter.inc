/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|*Assembly Writer Source Fragment                                             *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void TOYInstPrinter::printInstruction(const MCInst *MI, raw_ostream &O) {
  static const uint32_t OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// CFI_INSTRUCTION
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    110U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    103U,	// BUNDLE
    120U,	// LIFETIME_START
    90U,	// LIFETIME_END
    0U,	// STACKMAP
    0U,	// PATCHPOINT
    0U,	// LOAD_STACK_GUARD
    305U,	// ADDri
    305U,	// ADDrr
    769U,	// ADJCALLSTACKDOWN
    789U,	// ADJCALLSTACKUP
    822U,	// BL
    1343U,	// LDR
    8487U,	// MLA
    2377U,	// MOVHIi16
    4436U,	// MOVLOi16
    0U,	// MOVi32
    4431U,	// MOVrr
    314U,	// MUL
    135U,	// RET
    1348U,	// STR
    300U,	// SUBri
    300U,	// SUBrr
    0U
  };

  static const char AsmStrs[] = {
  /* 0 */ '#', 32, 'A', 'D', 'J', 'C', 'A', 'L', 'L', 'S', 'T', 'A', 'C', 'K', 'D', 'O', 'W', 'N', 32, 0,
  /* 20 */ '#', 32, 'A', 'D', 'J', 'C', 'A', 'L', 'L', 'S', 'T', 'A', 'C', 'K', 'U', 'P', 32, 0,
  /* 38 */ 'm', 'l', 'a', 32, 0,
  /* 43 */ 's', 'u', 'b', 32, 0,
  /* 48 */ 'a', 'd', 'd', 32, 0,
  /* 53 */ 'b', 'l', 32, 0,
  /* 57 */ 'm', 'u', 'l', 32, 0,
  /* 62 */ 'l', 'd', 'r', 32, 0,
  /* 67 */ 's', 't', 'r', 32, 0,
  /* 72 */ 'm', 'o', 'v', 't', 32, 0,
  /* 78 */ 'm', 'o', 'v', 32, 0,
  /* 83 */ 'm', 'o', 'v', 'w', 32, 0,
  /* 89 */ 'L', 'I', 'F', 'E', 'T', 'I', 'M', 'E', '_', 'E', 'N', 'D', 0,
  /* 102 */ 'B', 'U', 'N', 'D', 'L', 'E', 0,
  /* 109 */ 'D', 'B', 'G', '_', 'V', 'A', 'L', 'U', 'E', 0,
  /* 119 */ 'L', 'I', 'F', 'E', 'T', 'I', 'M', 'E', '_', 'S', 'T', 'A', 'R', 'T', 0,
  /* 134 */ 'b', 'x', 32, 'l', 'r', 0,
  };

  O << "\t";

  // Emit the opcode for the instruction.
  uint32_t Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 255)-1;


  // Fragment 0 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 8) & 1) {
    // ADDri, ADDrr, ADJCALLSTACKDOWN, ADJCALLSTACKUP, BL, LDR, MLA, MOVHIi16...
    printOperand(MI, 0, O); 
  } else {
    // DBG_VALUE, BUNDLE, LIFETIME_START, LIFETIME_END, RET
    return;
  }


  // Fragment 1 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 9) & 1) {
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, BL
    return;
  } else {
    // ADDri, ADDrr, LDR, MLA, MOVHIi16, MOVLOi16, MOVrr, MUL, STR, SUBri, SU...
    O << ", "; 
  }


  // Fragment 2 encoded into 2 bits for 3 unique commands.
  switch ((Bits >> 10) & 3) {
  default:   // unreachable.
  case 0:
    // ADDri, ADDrr, MLA, MOVLOi16, MOVrr, MUL, SUBri, SUBrr
    printOperand(MI, 1, O); 
    break;
  case 1:
    // LDR, STR
    printAddrModeMemSrc(MI, 1, O); 
    return;
    break;
  case 2:
    // MOVHIi16
    printOperand(MI, 2, O); 
    return;
    break;
  }


  // Fragment 3 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 12) & 1) {
    // MOVLOi16, MOVrr
    return;
  } else {
    // ADDri, ADDrr, MLA, MUL, SUBri, SUBrr
    O << ", "; 
    printOperand(MI, 2, O); 
  }


  // Fragment 4 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 13) & 1) {
    // MLA
    O << ", "; 
    printOperand(MI, 3, O); 
    return;
  } else {
    // ADDri, ADDrr, MUL, SUBri, SUBrr
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *TOYInstPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 13 && "Invalid register number!");

  static const char AsmStrs[] = {
  /* 0 */ 'r', '0', 0,
  /* 3 */ 'r', '1', 0,
  /* 6 */ 'r', '2', 0,
  /* 9 */ 'r', '3', 0,
  /* 12 */ 'r', '4', 0,
  /* 15 */ 'r', '5', 0,
  /* 18 */ 'r', '6', 0,
  /* 21 */ 'r', '7', 0,
  /* 24 */ 'r', '8', 0,
  /* 27 */ 'r', '9', 0,
  /* 30 */ 's', 'p', 0,
  /* 33 */ 'l', 'r', 0,
  };

  static const uint32_t RegAsmOffset[] = {
    33, 30, 0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 
  };

  assert (*(AsmStrs+RegAsmOffset[RegNo-1]) &&
          "Invalid alt name index for register!");
  return AsmStrs+RegAsmOffset[RegNo-1];
}

#ifdef PRINT_ALIAS_INSTR
#undef PRINT_ALIAS_INSTR

bool TOYInstPrinter::printAliasInstr(const MCInst *MI, raw_ostream &OS) {
  return false;
}

#endif // PRINT_ALIAS_INSTR
